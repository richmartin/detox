# detox
Java Data Transfer &amp; Value Objects made beautiful

# Objective
Value Objects in Java are a pain. Such a simple concept — an object representing a collection of fields — yet 
getting them right is both notoriously difficult, requiring well-crafted .equals() and .hashcode() methods, and 
requiring far too much boilerplate code that must be written and maintained.

```java
public final class User {
  private final long id;
  private final String name;
  private final InternetAddress emailAddress;
  private final DateTime dateOfBirth;

  public User(
      final long id,
      final String name,
      final InternetAddress emailAddress,
      final DateTime dateOfBirth) {
    this.id = id;
    this.name = name;
    this.emailAddress = emailAddress;
    this.dateOfBirth = dateOfBirth;
  }

  public long getId() {
    return id;
  }

  public String getName() {
    return name;
  }

  public InternetAddress getEmailAddress() {
    return emailAddress;
  }

  public DateTime getDateOfBirth() {
    return dateOfBirth;
  }

  @Override public boolean equals(final Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;

    final User user = (User) o;

    return id == user.id;

  }

  @Override public int hashCode() {
    return (int) (id ^ (id >>> 32));
  }
}
```

That's a lot of boilerplate for a value object consisting of just four simple members. The equals and hashcode 
methods above were generated by IntelliJ and could be simpler, but then if you are bothering to take the time 
to simplify these methods as the code evolves, you lose a lot of the benefits of getting the IDE to generate them for
you in the first place. Note that this simple class, long though it is, is far from complete: it omits a toString 
method, it omits any kind of validation or null-checking on the parameters to the constructor, it omits any kind of 
declaration as to the nullity of its fields (perhaps dateOfBirth is an optional field that some user provide), and it 
omits any kind “business” validation of the fields — e.g. requiring dateOfBirth to be in the past.

Instance construction is another problem here.

```java
User newUser = new User(nextAvailableUserId, name, emailAddress, null);
```

Invoking a constructor with four fields is manageable, but for a class with just a few more fields this approach to 
instance construction becomes an error-prone burden, especially if several fields are of the same type or may be null. 
An alternative to massive constructor parameter lists is to either introduce a hand-crafted fluent builder (even more
boilerplate), or use setters (eliminating the immutability property of the instance).
 
The same type with detox, looks like this:

```java
@GenerateBuilder
public interface User {
  @Id long getId();
  String getName();
  InternetAddress getInternetAddress();
  @Nullable DateTime getDateOfBirth();
}
```

And instance construction:

```java
User newUser = UserBuilder.newBuilder()
  .withId(nextAvailableUserId)
  .withName(name)
  .withEmailAddress(emailAddress)
  .build()
```

That's all there is to it. The generated builder will require (at compile time) that all of the mandatory fields are 
set before the build method is invoked. The generated instance will have appropriate equals, hashcode and toString 
methods.

# Usage
To use this magic, all you need to do is:
* Ensure the detox.jar is in your classpath
* Set-up your IDE to enable annotation processing and put the generated classes in your project's generated sources 
root

# Design Choices

## Why Interfaces?
In the above example, we modelled our User value object as an interface. This might be slightly surprising if you are
use to seeing value objects as classes, but it has some significant advantages. Decoupling the definition of what 
our value object _is_ from any particular implementation of it, is not only nice from a theoretical point of view, 
but it allows other specialized implementations to exist side-by-side in your codebase. For example,

An implementation designed to support JSON serialization for passing objects back and forth to the client. The code 
responsible for deserializing the request needs only return an instance of the User interface, rather than 
being forced to return a particular implementation: 

```java
User fromClient = serializationService.fromRequest(httpServletRequest);
```

An implementation designed for persistence in a database. Whatever persistence framework your project is using, you 
will typically have to implement a class to represent the stored data; with the framework often imposing 
onerous constraints on the design of the class: e.g. a public no-arg constructor (and, consequently, non-final 
fields), a non-final class, etc. It is then common to map back and forth between these persistence classes and the 
data-transfer classes, resulting in a a proliferation of mapping code for each entity. Detox, by using interfaces to 
define its value objects, allows the persistence classes to simply _implement_ the value object interface in the 
normal way,  

```java 
@com.googlecode.objectify.annotation.Entity
@com.googlecode.objectify.annotation.Cache
public final class UserEntity implements User {
  // All the persistence ugliness...
...
}
```

and the resulting object returned from your persistence code can be used seemlessly throughout your code together 
with other implementations of User.

This freedom comes from defining a value object as _what it is_ rather than _how it is implemented_.



# JSON Serialization
(Documentation coming soon)