# detox
Java Data Transfer &amp; Value Objects made beautiful

# Objective
Value Objects in Java are a pain. Such a simple concept — a object representing some a collection of fields — yet 
getting them right is both notoriously difficult, requiring well-crafted .equals() and .hashcode() methods, and 
requiring far too much boilerplate code that must be written and maintained.

```java
public final class User {
  private final long id;
  private final String name;
  private final InternetAddress emailAddress;
  private final DateTime dateOfBirth;

  public User(
      final long id,
      final String name,
      final InternetAddress emailAddress,
      final DateTime dateOfBirth) {
    this.id = id;
    this.name = name;
    this.emailAddress = emailAddress;
    this.dateOfBirth = dateOfBirth;
  }

  public long getId() {
    return id;
  }

  public String getName() {
    return name;
  }

  public InternetAddress getEmailAddress() {
    return emailAddress;
  }

  public DateTime getDateOfBirth() {
    return dateOfBirth;
  }

  @Override public boolean equals(final Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;

    final User user = (User) o;

    return id == user.id;

  }

  @Override public int hashCode() {
    return (int) (id ^ (id >>> 32));
  }
}
```

That's a lot of boilerplate for a value object consisting of just four simple members. The equals and hashcode 
methods above were generated by IntelliJ and could be simpler, but then if you are bothering to take the time 
to simplify these methods as the code evolves, you lose a lot of the benefits of getting the IDE to generate them for
you in the first place. Note that this simple class, long though it is, is far from complete: it omits a toString 
method, it omits any kind of validation or null-checking on the parameters to the constructor, it omits any kind of 
declaration as to the nullity of its fields (perhaps dateOfBirth is an optional field that some user provide), and it 
omits any kind “business” validation of the fields — e.g. requiring dateOfBirth to be in the past.

Instance construction is another problem here.

```java
User newUser = new User(nextAvailableUserId, name, emailAddress, null);
```

Invoking a constructor with four fields is manageable, but for a class with just a few more fields this approach to 
instance construction becomes an error-prone burden, especially if several fields are of the same type or may be null. 
An alternative to massive constructor parameter lists is to either introduce a hand-crafted fluent builder (even more
boilerplate), or use setters (eliminating the immutability property of the instance).
 
The same type with detox, looks like this:

```java
@GenerateBuilder
public interface User {
  @Id long getId();
  String getName();
  InternetAddress getInternetAddress();
  @Nullable DateTime getDateOfBirth();
}
```

And instance construction:

```java
User newUser = UserBuilder.newBuilder()
  .withId(nextAvailableUserId)
  .withName(name)
  .withEmailAddress(emailAddress)
  .build()
```

That's all there is to it. The generated builder will require (at compile time) that all of the mandatory fields are 
set before the build method is invoked. The generated instance will have appropriate equals, hashcode and toString 
methods.

# Usage
To use this magic, all you need to do is:
* Ensure the detox.jar is in your classpath
* Set-up your IDE to enable annotation processing and put the generated classes in your project's generated sources 
root
 
# JSON Serialization
(Documentation coming soon)